name: Deploy AutoLog with Terraform

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'test'
        type: choice
        options:
        - test
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
        - plan
        - apply
        - destroy
      use_azure_registry:
        description: 'Use Azure Container Registry (false = use Docker Hub)'
        required: false
        default: false
        type: boolean

env:
  TF_VERSION: "1.5.0"
  AZURE_CLI_VERSION: "2.53.0"

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Install dependencies
      run: |
        cd frontend && npm ci
        cd ../backend && go mod download
    
    - name: Run backend tests
      run: |
        cd backend
        go test ./...
    
    - name: Run frontend tests
      run: |
        cd frontend
        npm test -- --watchAll=false
    
    - name: Build frontend
      run: |
        cd frontend
        npm run build

  build-images:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Determine registry configuration
      id: registry
      run: |
        USE_AZURE_REGISTRY="${{ github.event.inputs.use_azure_registry || 'false' }}"
        DOCKER_HUB_USERNAME="${{ secrets.DOCKER_HUB_USERNAME || 'autolog' }}"
        
        if [ "$USE_AZURE_REGISTRY" = "true" ]; then
          # Use Azure Container Registry
          ACR_NAME="autologregistrytest"
          REGISTRY_URL="$ACR_NAME.azurecr.io"
          echo "registry_type=azure" >> $GITHUB_OUTPUT
          echo "registry_url=$REGISTRY_URL" >> $GITHUB_OUTPUT
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
        else
          # Use Docker Hub
          REGISTRY_URL="docker.io/$DOCKER_HUB_USERNAME"
          echo "registry_type=dockerhub" >> $GITHUB_OUTPUT
          echo "registry_url=$REGISTRY_URL" >> $GITHUB_OUTPUT
        fi
    
    - name: Login to Azure (if using ACR)
      if: steps.registry.outputs.registry_type == 'azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Get ACR credentials (if using ACR)
      if: steps.registry.outputs.registry_type == 'azure'
      id: acr
      run: |
        ACR_NAME="${{ steps.registry.outputs.acr_name }}"
        
        # Get ACR credentials
        ACR_USERNAME=$(az acr credential show --name $ACR_NAME --query username --output tsv)
        ACR_PASSWORD=$(az acr credential show --name $ACR_NAME --query passwords[0].value --output tsv)
        echo "acr_username=$ACR_USERNAME" >> $GITHUB_OUTPUT
        echo "acr_password=$ACR_PASSWORD" >> $GITHUB_OUTPUT
    
    - name: Login to Azure Container Registry (if using ACR)
      if: steps.registry.outputs.registry_type == 'azure'
      uses: azure/docker-login@v1
      with:
        login-server: ${{ steps.registry.outputs.registry_url }}
        username: ${{ steps.acr.outputs.acr_username }}
        password: ${{ steps.acr.outputs.acr_password }}
    
    - name: Login to Docker Hub (if using Docker Hub)
      if: steps.registry.outputs.registry_type == 'dockerhub'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}
    
    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile.prod
        push: true
        tags: |
          ${{ steps.registry.outputs.registry_url }}/backend:${{ github.sha }}
          ${{ steps.registry.outputs.registry_url }}/backend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile.prod
        push: true
        tags: |
          ${{ steps.registry.outputs.registry_url }}/frontend:${{ github.sha }}
          ${{ steps.registry.outputs.registry_url }}/frontend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Build and push log parser image
      uses: docker/build-push-action@v5
      with:
        context: ./logparser_service
        push: true
        tags: |
          ${{ steps.registry.outputs.registry_url }}/logparser:${{ github.sha }}
          ${{ steps.registry.outputs.registry_url }}/logparser:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

  terraform:
    needs: build-images
    runs-on: ubuntu-latest
    environment: test
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
    
    - name: Setup Azure CLI
      uses: azure/setup-azure-cli@v3
      with:
        version: ${{ env.AZURE_CLI_VERSION }}
    
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform Backend
      run: |
        # For test environments, we'll use local backend (simpler, no Azure storage required)
        # If you want to use Azure storage for state, uncomment the azurerm backend in main.tf
        # and uncomment the storage account creation below
        
        # # Create storage account for Terraform state (optional)
        # STORAGE_ACCOUNT="autologtfstatetest"
        # RESOURCE_GROUP="autolog-terraform-rg"
        # CONTAINER="tfstate"
        # 
        # # Create resource group if it doesn't exist
        # az group create --name $RESOURCE_GROUP --location eastus --output none || true
        # 
        # # Create storage account if it doesn't exist
        # az storage account create \
        #   --resource-group $RESOURCE_GROUP \
        #   --name $STORAGE_ACCOUNT \
        #   --sku Standard_LRS \
        #   --encryption-services blob \
        #   --output none || true
        # 
        # # Create blob container if it doesn't exist
        # az storage container create \
        #   --name $CONTAINER \
        #   --account-name $STORAGE_ACCOUNT \
        #   --output none || true
        
        echo "Using local backend for test environment"
    
    - name: Terraform Init
      working-directory: terraform
      run: terraform init
    
    - name: Terraform Plan
      working-directory: terraform
      run: |
        terraform plan \
          -var="environment=test" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -var="jwt_secret=${{ secrets.JWT_SECRET }}" \
          -var="use_azure_registry=${{ github.event.inputs.use_azure_registry || 'false' }}" \
          -var="container_registry_url=${{ steps.registry.outputs.registry_url }}" \
          -out=tfplan
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
    
    - name: Terraform Apply
      if: github.event.inputs.action == 'apply' || github.event_name == 'push'
      working-directory: terraform
      run: terraform apply -auto-approve tfplan
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
    
    - name: Terraform Destroy
      if: github.event.inputs.action == 'destroy'
      working-directory: terraform
      run: |
        terraform destroy \
          -var="environment=test" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -var="jwt_secret=${{ secrets.JWT_SECRET }}" \
          -var="use_azure_registry=${{ github.event.inputs.use_azure_registry || 'false' }}" \
          -var="container_registry_url=${{ steps.registry.outputs.registry_url }}" \
          -auto-approve
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
    
    - name: Output Infrastructure Info
      if: github.event.inputs.action == 'apply' || github.event_name == 'push'
      working-directory: terraform
      run: |
        echo "=== Infrastructure Deployment Summary ==="
        echo "Environment: test"
        echo "Registry Type: ${{ steps.registry.outputs.registry_type }}"
        echo "Registry URL: ${{ steps.registry.outputs.registry_url }}"
        echo ""
        echo "=== Resource URLs ==="
        terraform output -json | jq -r 'to_entries[] | "\(.key): \(.value)"'
        echo ""
        echo "=== Cost Estimate ==="
        terraform output estimated_monthly_cost
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

  cleanup:
    if: failure() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    needs: [build-images, terraform]
    
    steps:
    - name: Setup Azure CLI
      uses: azure/setup-azure-cli@v3
    
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Cleanup failed deployment
      run: |
        echo "Cleaning up failed deployment..."
        RESOURCE_GROUP="autolog-${{ github.event.inputs.environment || 'test' }}-rg"
        az group delete --name $RESOURCE_GROUP --yes --no-wait || true
        echo "Cleanup initiated" 